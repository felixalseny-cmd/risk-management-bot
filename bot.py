import os
import logging
import asyncio
import re
import time
import functools
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
    ConversationHandler,
    CallbackQueryHandler
)

# Logging setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Conversation states
(
    MAIN_MENU, INSTRUMENT_TYPE, CUSTOM_INSTRUMENT, DIRECTION, 
    RISK_PERCENT, DEPOSIT, LEVERAGE, CURRENCY, ENTRY, 
    STOP_LOSS, TAKE_PROFITS, VOLUME_DISTRIBUTION,
    PORTFOLIO_MENU, ANALYTICS_MENU, TRADE_HISTORY, PERFORMANCE_ANALYSIS
) = range(16)

# Temporary storage
user_data: Dict[int, Dict[str, Any]] = {}

# Portfolio Data Management
class PortfolioManager:
    @staticmethod
    def initialize_user_portfolio(user_id: int):
        if user_id not in user_data:
            user_data[user_id] = {}
        
        if 'portfolio' not in user_data[user_id]:
            user_data[user_id]['portfolio'] = {
                'initial_balance': 0,
                'current_balance': 0,
                'trades': [],
                'performance': {
                    'total_trades': 0,
                    'winning_trades': 0,
                    'losing_trades': 0,
                    'total_profit': 0,
                    'total_loss': 0,
                    'win_rate': 0,
                    'average_profit': 0,
                    'average_loss': 0
                },
                'allocation': {},
                'history': []
            }
    
    @staticmethod
    def add_trade(user_id: int, trade_data: Dict):
        PortfolioManager.initialize_user_portfolio(user_id)
        
        trade_id = len(user_data[user_id]['portfolio']['trades']) + 1
        trade_data['id'] = trade_id
        trade_data['timestamp'] = datetime.now().isoformat()
        
        user_data[user_id]['portfolio']['trades'].append(trade_data)
        
        # Update performance metrics
        PortfolioManager.update_performance_metrics(user_id)
        
        # Update allocation
        instrument = trade_data.get('instrument', 'Unknown')
        if instrument not in user_data[user_id]['portfolio']['allocation']:
            user_data[user_id]['portfolio']['allocation'][instrument] = 0
        user_data[user_id]['portfolio']['allocation'][instrument] += 1
        
        # Add to history
        user_data[user_id]['portfolio']['history'].append({
            'type': 'trade',
            'action': 'open' if trade_data.get('status') == 'open' else 'close',
            'instrument': instrument,
            'profit': trade_data.get('profit', 0),
            'timestamp': trade_data['timestamp']
        })
    
    @staticmethod
    def update_performance_metrics(user_id: int):
        portfolio = user_data[user_id]['portfolio']
        trades = portfolio['trades']
        
        if not trades:
            return
        
        closed_trades = [t for t in trades if t.get('status') == 'closed']
        winning_trades = [t for t in closed_trades if t.get('profit', 0) > 0]
        losing_trades = [t for t in closed_trades if t.get('profit', 0) <= 0]
        
        portfolio['performance']['total_trades'] = len(closed_trades)
        portfolio['performance']['winning_trades'] = len(winning_trades)
        portfolio['performance']['losing_trades'] = len(losing_trades)
        portfolio['performance']['total_profit'] = sum(t.get('profit', 0) for t in winning_trades)
        portfolio['performance']['total_loss'] = sum(t.get('profit', 0) for t in losing_trades)
        
        if closed_trades:
            portfolio['performance']['win_rate'] = (len(winning_trades) / len(closed_trades)) * 100
            portfolio['performance']['average_profit'] = (
                portfolio['performance']['total_profit'] / len(winning_trades) 
                if winning_trades else 0
            )
            portfolio['performance']['average_loss'] = (
                portfolio['performance']['total_loss'] / len(losing_trades) 
                if losing_trades else 0
            )
    
    @staticmethod
    def add_balance_operation(user_id: int, operation_type: str, amount: float, description: str = ""):
        PortfolioManager.initialize_user_portfolio(user_id)
        
        user_data[user_id]['portfolio']['history'].append({
            'type': 'balance',
            'action': operation_type,
            'amount': amount,
            'description': description,
            'timestamp': datetime.now().isoformat()
        })
        
        if operation_type == 'deposit':
            user_data[user_id]['portfolio']['current_balance'] += amount
            if user_data[user_id]['portfolio']['initial_balance'] == 0:
                user_data[user_id]['portfolio']['initial_balance'] = amount

# Analytics Engine
class AnalyticsEngine:
    @staticmethod
    def calculate_risk_reward_analysis(trades: List[Dict]) -> Dict[str, Any]:
        closed_trades = [t for t in trades if t.get('status') == 'closed']
        
        if not closed_trades:
            return {
                'average_risk_reward': 0,
                'best_trade': 0,
                'worst_trade': 0,
                'consistency_score': 0,
                'risk_score': 0
            }
        
        risk_reward_ratios = []
        profits = []
        
        for trade in closed_trades:
            risk = trade.get('risk_amount', 0)
            profit = trade.get('profit', 0)
            
            if risk > 0:
                risk_reward_ratios.append(abs(profit / risk))
            profits.append(profit)
        
        return {
            'average_risk_reward': sum(risk_reward_ratios) / len(risk_reward_ratios) if risk_reward_ratios else 0,
            'best_trade': max(profits) if profits else 0,
            'worst_trade': min(profits) if profits else 0,
            'consistency_score': AnalyticsEngine.calculate_consistency(profits),
            'risk_score': AnalyticsEngine.calculate_risk_score(profits)
        }
    
    @staticmethod
    def calculate_consistency(profits: List[float]) -> float:
        if len(profits) < 2:
            return 0
        
        positive_profits = [p for p in profits if p > 0]
        if not positive_profits:
            return 0
        
        return (len(positive_profits) / len(profits)) * 100
    
    @staticmethod
    def calculate_risk_score(profits: List[float]) -> float:
        if not profits:
            return 0
        
        avg_profit = sum(profits) / len(profits)
        if avg_profit == 0:
            return 0
        
        # Simple risk score based on profit stability
        positive_count = len([p for p in profits if p > 0])
        return (positive_count / len(profits)) * 100
    
    @staticmethod
    def generate_strategy_recommendations(portfolio: Dict) -> List[str]:
        recommendations = []
        performance = portfolio.get('performance', {})
        
        win_rate = performance.get('win_rate', 0)
        avg_profit = performance.get('average_profit', 0)
        avg_loss = performance.get('average_loss', 0)
        
        if win_rate < 40:
            recommendations.append("üìâ –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–Ω–∏–∂–µ–Ω–∏–µ —Ä–∏—Å–∫–∞ –Ω–∞ —Å–¥–µ–ª–∫—É –¥–æ 1-2%")
            recommendations.append("üéØ –£–≤–µ–ª–∏—á—å—Ç–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ –¥–æ 1:3")
        
        if avg_profit < abs(avg_loss) and win_rate > 50:
            recommendations.append("‚ö° –£–ª—É—á—à–∏—Ç–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–µ–π - —Ñ–∏–∫—Å–∏—Ä—É–π—Ç–µ –ø—Ä–∏–±—ã–ª—å —Ä–∞–Ω—å—à–µ")
        
        if len(portfolio.get('allocation', {})) < 3:
            recommendations.append("üåê –î–∏–≤–µ—Ä—Å–∏—Ñ–∏—Ü–∏—Ä—É–π—Ç–µ –ø–æ—Ä—Ç—Ñ–µ–ª—å - —Ç–æ—Ä–≥—É–π—Ç–µ —Ä–∞–∑–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã")
        
        if not recommendations:
            recommendations.append("‚úÖ –í–∞—à–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ö–æ—Ä–æ—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ")
        
        return recommendations

# Ultra-fast cache manager (existing)
class FastCache:
    def __init__(self, max_size=500, ttl=300):
        self.cache = {}
        self.max_size = max_size
        self.ttl = ttl
    
    def get(self, key):
        if key in self.cache:
            data, timestamp = self.cache[key]
            if time.time() - timestamp < self.ttl:
                return data
            else:
                del self.cache[key]
        return None
    
    def set(self, key, value):
        if len(self.cache) >= self.max_size:
            self.cache.clear()
        self.cache[key] = (value, time.time())

# Global cache
fast_cache = FastCache()

# Constants (existing)
INSTRUMENT_TYPES = {
    'forex': 'Forex',
    'crypto': '–ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã', 
    'indices': '–ò–Ω–¥–µ–∫—Å—ã',
    'commodities': '–¢–æ–≤–∞—Ä—ã',
    'metals': '–ú–µ—Ç–∞–ª–ª—ã'
}

PIP_VALUES = {
    # ... (existing PIP_VALUES dictionary)
}

CONTRACT_SIZES = {
    'forex': 100000,
    'crypto': 1,
    'indices': 1,
    'commodities': 100,
    'metals': 100
}

LEVERAGES = ['1:10', '1:20', '1:50', '1:100', '1:200', '1:500', '1:1000']
RISK_LEVELS = ['2%', '5%', '10%', '15%', '20%', '25%']
TRADE_DIRECTIONS = ['BUY', 'SELL']

# Ultra-fast risk calculator (existing)
class FastRiskCalculator:
    # ... (existing FastRiskCalculator implementation)
    pass

# Performance logging decorator (existing)
def log_performance(func):
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        result = await func(*args, **kwargs)
        execution_time = time.time() - start_time
        if execution_time > 1.0:
            logger.warning(f"Slow operation: {func.__name__} took {execution_time:.2f}s")
        return result
    return wrapper

# Enhanced Portfolio Management
@log_performance
async def portfolio_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Enhanced Portfolio Management"""
    user_id = update.message.from_user.id if update.message else update.callback_query.from_user.id
    
    # Initialize portfolio if not exists
    PortfolioManager.initialize_user_portfolio(user_id)
    
    portfolio_text = """
üíº *–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ü–æ—Ä—Ç—Ñ–µ–ª–µ–º*

üìä *–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:*
‚Ä¢ üìà –û–±–∑–æ—Ä –≤—Å–µ—Ö —Å–¥–µ–ª–æ–∫
‚Ä¢ üí∞ –ë–∞–ª–∞–Ω—Å –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
‚Ä¢ üìä –ê–Ω–∞–ª–∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
‚Ä¢ üîÑ –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:
"""
    
    keyboard = [
        [InlineKeyboardButton("üìà –û–±–∑–æ—Ä —Å–¥–µ–ª–æ–∫", callback_data="portfolio_trades")],
        [InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ", callback_data="portfolio_balance")],
        [InlineKeyboardButton("üìä –ê–Ω–∞–ª–∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏", callback_data="portfolio_performance")],
        [InlineKeyboardButton("üîÑ –ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π", callback_data="portfolio_history")],
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–¥–µ–ª–∫—É", callback_data="portfolio_add_trade")],
        [InlineKeyboardButton("üí∏ –í–Ω–µ—Å—Ç–∏ –¥–µ–ø–æ–∑–∏—Ç", callback_data="portfolio_deposit")],
        [InlineKeyboardButton("üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
    ]
    
    if update.message:
        await update.message.reply_text(
            portfolio_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        await update.callback_query.edit_message_text(
            portfolio_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    return PORTFOLIO_MENU

@log_performance
async def portfolio_trades(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Display trade overview"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    trades = portfolio.get('trades', [])
    
    if not trades:
        await query.edit_message_text(
            "üì≠ *–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç —Å–¥–µ–ª–æ–∫*\n\n"
            "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É '‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–¥–µ–ª–∫—É' –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏.",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–¥–µ–ª–∫—É", callback_data="portfolio_add_trade")],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
            ])
        )
        return
    
    # Display last 5 trades
    recent_trades = trades[-5:]
    trades_text = "üìà *–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–¥–µ–ª–∫–∏:*\n\n"
    
    for trade in reversed(recent_trades):
        status_emoji = "üü¢" if trade.get('profit', 0) > 0 else "üî¥" if trade.get('profit', 0) < 0 else "‚ö™"
        trades_text += (
            f"{status_emoji} *{trade.get('instrument', 'N/A')}* | "
            f"{trade.get('direction', 'N/A')} | "
            f"–ü—Ä–∏–±—ã–ª—å: ${trade.get('profit', 0):.2f}\n"
            f"üìÖ {trade.get('timestamp', '')[:16]}\n\n"
        )
    
    trades_text += f"üìä –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫: {len(trades)}"
    
    await query.edit_message_text(
        trades_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üìã –í—Å—è –∏—Å—Ç–æ—Ä–∏—è", callback_data="portfolio_full_history")],
            [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å–¥–µ–ª–∫—É", callback_data="portfolio_add_trade")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

@log_performance
async def portfolio_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Display balance and allocation"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    allocation = portfolio.get('allocation', {})
    performance = portfolio.get('performance', {})
    
    balance_text = "üí∞ *–ë–∞–ª–∞–Ω—Å –∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ*\n\n"
    
    # Balance information
    initial_balance = portfolio.get('initial_balance', 0)
    current_balance = portfolio.get('current_balance', 0)
    total_profit = performance.get('total_profit', 0)
    total_loss = performance.get('total_loss', 0)
    net_profit = total_profit + total_loss
    
    balance_text += f"üí≥ –ù–∞—á–∞–ª—å–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç: ${initial_balance:,.2f}\n"
    balance_text += f"üíµ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: ${current_balance:,.2f}\n"
    balance_text += f"üìà –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: ${net_profit:,.2f}\n\n"
    
    # Allocation information
    if allocation:
        balance_text += "üåê *–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º:*\n"
        for instrument, count in list(allocation.items())[:5]:  # Show top 5
            balance_text += f"‚Ä¢ {instrument}: {count} —Å–¥–µ–ª–æ–∫\n"
    else:
        balance_text += "üåê *–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ:* –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö\n"
    
    await query.edit_message_text(
        balance_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üí∏ –í–Ω–µ—Å—Ç–∏ –¥–µ–ø–æ–∑–∏—Ç", callback_data="portfolio_deposit")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

@log_performance
async def portfolio_performance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Display performance analysis"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    performance = portfolio.get('performance', {})
    
    perf_text = "üìä *–ê–Ω–∞–ª–∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏*\n\n"
    
    # Performance metrics
    total_trades = performance.get('total_trades', 0)
    win_rate = performance.get('win_rate', 0)
    avg_profit = performance.get('average_profit', 0)
    avg_loss = performance.get('average_loss', 0)
    
    perf_text += f"üìà –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫: {total_trades}\n"
    perf_text += f"üéØ –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö: {win_rate:.1f}%\n"
    perf_text += f"üí∞ –°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å: ${avg_profit:.2f}\n"
    perf_text += f"üìâ –°—Ä–µ–¥–Ω–∏–π —É–±—ã—Ç–æ–∫: ${avg_loss:.2f}\n\n"
    
    # Risk analysis
    risk_reward_data = AnalyticsEngine.calculate_risk_reward_analysis(
        portfolio.get('trades', [])
    )
    
    perf_text += f"‚ö° –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ: {risk_reward_data['average_risk_reward']:.2f}\n"
    perf_text += f"üèÜ –õ—É—á—à–∞—è —Å–¥–µ–ª–∫–∞: ${risk_reward_data['best_trade']:.2f}\n"
    perf_text += f"üîª –•—É–¥—à–∞—è —Å–¥–µ–ª–∫–∞: ${risk_reward_data['worst_trade']:.2f}\n\n"
    
    # Recommendations
    recommendations = AnalyticsEngine.generate_strategy_recommendations(portfolio)
    if recommendations:
        perf_text += "üí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n"
        for rec in recommendations[:3]:  # Show top 3 recommendations
            perf_text += f"‚Ä¢ {rec}\n"
    
    await query.edit_message_text(
        perf_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üìà –î–µ—Ç–∞–ª—å–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞", callback_data="analytics_detailed")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

@log_performance
async def portfolio_history(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Display operation history"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    history = portfolio.get('history', [])
    
    if not history:
        await query.edit_message_text(
            "üì≠ *–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π –ø—É—Å—Ç–∞*\n\n"
            "–ó–¥–µ—Å—å –±—É–¥—É—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤—Å–µ –≤–∞—à–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–æ —Å—á–µ—Ç—É.",
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí∏ –í–Ω–µ—Å—Ç–∏ –¥–µ–ø–æ–∑–∏—Ç", callback_data="portfolio_deposit")],
                [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
            ])
        )
        return
    
    history_text = "üîÑ *–ò—Å—Ç–æ—Ä–∏—è –æ–ø–µ—Ä–∞—Ü–∏–π*\n\n"
    
    # Show last 10 operations
    for op in reversed(history[-10:]):
        emoji = "üí≥" if op['type'] == 'balance' else "üìà"
        action_emoji = "‚¨ÜÔ∏è" if op.get('amount', 0) > 0 else "‚¨áÔ∏è"
        
        history_text += f"{emoji} {op['type'].title()} | {op['action']} {action_emoji}\n"
        
        if op['type'] == 'balance':
            history_text += f"üíµ –°—É–º–º–∞: ${op.get('amount', 0):.2f}\n"
        else:
            history_text += f"üí∞ –ü—Ä–∏–±—ã–ª—å: ${op.get('profit', 0):.2f}\n"
        
        history_text += f"üìÖ {op.get('timestamp', '')[:16]}\n\n"
    
    await query.edit_message_text(
        history_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

@log_performance
async def portfolio_add_trade(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add a new trade to portfolio"""
    query = update.callback_query
    user_id = query.from_user.id
    
    # For demo purposes, adding a sample trade
    sample_trade = {
        'instrument': 'EURUSD',
        'direction': 'BUY',
        'volume': 0.1,
        'entry_price': 1.0850,
        'exit_price': 1.0900,
        'profit': 50.0,
        'risk_amount': 20.0,
        'status': 'closed',
        'strategy': 'Breakout'
    }
    
    PortfolioManager.add_trade(user_id, sample_trade)
    
    await query.edit_message_text(
        "‚úÖ *–°–¥–µ–ª–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –ø–æ—Ä—Ç—Ñ–µ–ª—å!*\n\n"
        f"üìà {sample_trade['instrument']} {sample_trade['direction']}\n"
        f"üí∞ –ü—Ä–∏–±—ã–ª—å: ${sample_trade['profit']:.2f}\n\n"
        "–û–±–Ω–æ–≤–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –Ω–æ–≤–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.",
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üìä –û–±–Ω–æ–≤–∏—Ç—å –∞–Ω–∞–ª–∏—Ç–∏–∫—É", callback_data="portfolio_performance")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

@log_performance
async def portfolio_deposit(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Add deposit to portfolio"""
    query = update.callback_query
    user_id = query.from_user.id
    
    # For demo purposes, adding a sample deposit
    PortfolioManager.add_balance_operation(
        user_id, 
        'deposit', 
        1000.0, 
        "–ù–∞—á–∞–ª—å–Ω—ã–π –¥–µ–ø–æ–∑–∏—Ç"
    )
    
    await query.edit_message_text(
        "‚úÖ *–î–µ–ø–æ–∑–∏—Ç –¥–æ–±–∞–≤–ª–µ–Ω!*\n\n"
        "üíµ –°—É–º–º–∞: $1,000.00\n\n"
        "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å –±–∞–ª–∞–Ω—Å –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤–∞—à–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è.",
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üí∞ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–∞–ª–∞–Ω—Å", callback_data="portfolio_balance")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –ø–æ—Ä—Ç—Ñ–µ–ª—é", callback_data="portfolio_back")]
        ])
    )

# Enhanced Analytics System
@log_performance
async def analytics_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Enhanced Strategy Analytics"""
    user_id = update.message.from_user.id if update.message else update.callback_query.from_user.id
    
    analytics_text = """
üìà *–ê–Ω–∞–ª–∏—Ç–∏–∫–∞ –°—Ç—Ä–∞—Ç–µ–≥–∏–π*

üìä *–î–æ—Å—Ç—É–ø–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞:*
‚Ä¢ üìà –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ
‚Ä¢ üíπ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
‚Ä¢ üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–¥–µ–ª–æ–∫
‚Ä¢ üîÑ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

üöÄ *–°–∫–æ—Ä–æ –ø–æ—è–≤–∏—Ç—Å—è:*
‚Ä¢ ü§ñ AI-–∞–Ω–∞–ª–∏–∑ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
‚Ä¢ üìä –ë—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥
‚Ä¢ üìà –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ
‚Ä¢ üí° –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏

–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∞–Ω–∞–ª–∏–∑–∞:
"""
    
    keyboard = [
        [InlineKeyboardButton("üìà –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ", callback_data="analytics_risk_reward")],
        [InlineKeyboardButton("üíπ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–π", callback_data="analytics_strategy_perf")],
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–¥–µ–ª–æ–∫", callback_data="analytics_trade_stats")],
        [InlineKeyboardButton("üîÑ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤", callback_data="analytics_optimization")],
        [InlineKeyboardButton("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="analytics_recommendations")],
        [InlineKeyboardButton("üîô –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]
    ]
    
    if update.message:
        await update.message.reply_text(
            analytics_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    else:
        await update.callback_query.edit_message_text(
            analytics_text,
            parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    return ANALYTICS_MENU

@log_performance
async def analytics_risk_reward(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Risk/Reward Analysis"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    trades = portfolio.get('trades', [])
    
    analysis = AnalyticsEngine.calculate_risk_reward_analysis(trades)
    
    risk_text = "üìà *–ê–Ω–∞–ª–∏–∑ –†–∏—Å–∫/–í–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ*\n\n"
    
    risk_text += f"‚ö° –°—Ä–µ–¥–Ω–µ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ R/R: {analysis['average_risk_reward']:.2f}\n"
    risk_text += f"üèÜ –õ—É—á—à–∞—è —Å–¥–µ–ª–∫–∞: ${analysis['best_trade']:.2f}\n"
    risk_text += f"üîª –•—É–¥—à–∞—è —Å–¥–µ–ª–∫–∞: ${analysis['worst_trade']:.2f}\n"
    risk_text += f"üéØ –û—Ü–µ–Ω–∫–∞ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏: {analysis['consistency_score']:.1f}%\n"
    risk_text += f"‚ö†Ô∏è –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {analysis['risk_score']:.1f}/100\n\n"
    
    # Recommendations based on risk analysis
    if analysis['average_risk_reward'] < 1:
        risk_text += "üí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:* –£–≤–µ–ª–∏—á—å—Ç–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ –¥–æ 1:3\n"
    elif analysis['average_risk_reward'] > 3:
        risk_text += "üí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:* –û—Ç–ª–∏—á–Ω–æ–µ —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ\n"
    
    if analysis['risk_score'] < 30:
        risk_text += "üîª –°–Ω–∏–∑—å—Ç–µ —Ä–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É –¥–æ 1-2% –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞\n"
    
    await query.edit_message_text(
        risk_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üíπ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–π", callback_data="analytics_strategy_perf")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ", callback_data="analytics_back")]
        ])
    )

@log_performance
async def analytics_strategy_perf(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Strategy Performance Analysis"""
    query = update.callback_query
    
    perf_text = "üíπ *–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –°—Ç—Ä–∞—Ç–µ–≥–∏–π*\n\n"
    
    # Sample strategy performance data
    strategies = {
        'Breakout': {'win_rate': 65, 'avg_profit': 45, 'total_trades': 23},
        'Trend Following': {'win_rate': 58, 'avg_profit': 32, 'total_trades': 15},
        'Mean Reversion': {'win_rate': 72, 'avg_profit': 28, 'total_trades': 18}
    }
    
    for strategy, stats in strategies.items():
        perf_text += f"üéØ *{strategy}*\n"
        perf_text += f"   üìä –í–∏–Ω—Ä–µ–π—Ç: {stats['win_rate']}%\n"
        perf_text += f"   üí∞ –°—Ä–µ–¥–Ω—è—è –ø—Ä–∏–±—ã–ª—å: ${stats['avg_profit']:.2f}\n"
        perf_text += f"   üìà –°–¥–µ–ª–æ–∫: {stats['total_trades']}\n\n"
    
    perf_text += "üí° *–õ—É—á—à–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è:* Breakout (65% —É—Å–ø–µ—à–Ω—ã—Ö —Å–¥–µ–ª–æ–∫)"
    
    await query.edit_message_text(
        perf_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–¥–µ–ª–æ–∫", callback_data="analytics_trade_stats")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ", callback_data="analytics_back")]
        ])
    )

@log_performance
async def analytics_trade_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Trade Statistics"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    performance = portfolio.get('performance', {})
    
    stats_text = "üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –°–¥–µ–ª–æ–∫*\n\n"
    
    total_trades = performance.get('total_trades', 0)
    win_rate = performance.get('win_rate', 0)
    profit_factor = (
        abs(performance.get('total_profit', 0) / performance.get('total_loss', 1)) 
        if performance.get('total_loss', 0) != 0 else 0
    )
    
    stats_text += f"üìà –í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫: {total_trades}\n"
    stats_text += f"üéØ –ü—Ä–æ—Ü–µ–Ω—Ç –ø—Ä–∏–±—ã–ª—å–Ω—ã—Ö: {win_rate:.1f}%\n"
    stats_text += f"üí∞ –§–∞–∫—Ç–æ—Ä –ø—Ä–∏–±—ã–ª–∏: {profit_factor:.2f}\n"
    stats_text += f"‚ö° –ú–∞–∫—Å. —Å–µ—Ä–∏—è –ø—Ä–∏–±—ã–ª–µ–π: {performance.get('winning_trades', 0)}\n"
    stats_text += f"üîª –ú–∞–∫—Å. —Å–µ—Ä–∏—è —É–±—ã—Ç–∫–æ–≤: {performance.get('losing_trades', 0)}\n\n"
    
    # Performance rating
    if win_rate >= 60 and profit_factor >= 1.5:
        rating = "üèÜ –û–¢–õ–ò–ß–ù–û"
    elif win_rate >= 50 and profit_factor >= 1.2:
        rating = "‚úÖ –•–û–†–û–®–û"
    else:
        rating = "‚ö†Ô∏è –¢–†–ï–ë–£–ï–¢–°–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø"
    
    stats_text += f"üìä *–û—Ü–µ–Ω–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:* {rating}"
    
    await query.edit_message_text(
        stats_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üîÑ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤", callback_data="analytics_optimization")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ", callback_data="analytics_back")]
        ])
    )

@log_performance
async def analytics_optimization(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Parameter Optimization"""
    query = update.callback_query
    
    opt_text = "üîÑ *–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ü–∞—Ä–∞–º–µ—Ç—Ä–æ–≤*\n\n"
    
    opt_text += "üéØ *–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:*\n"
    opt_text += "‚Ä¢ üìâ –†–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É: 1-2% –æ—Ç –¥–µ–ø–æ–∑–∏—Ç–∞\n"
    opt_text += "‚Ä¢ ‚ö° –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ R/R: 1:3 –∏–ª–∏ –≤—ã—à–µ\n"
    opt_text += "‚Ä¢ üìä –†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç\n"
    opt_text += "‚Ä¢ üõë –°—Ç–æ–ø-–ª–æ—Å—Å: –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ—Ü–µ–Ω—Ç\n\n"
    
    opt_text += "üí° *–°–æ–≤–µ—Ç—ã –ø–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:*\n"
    opt_text += "‚Ä¢ –¢–µ—Å—Ç–∏—Ä—É–π—Ç–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö\n"
    opt_text += "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–∞–∑–Ω—ã–µ —Ç–∞–π–º—Ñ—Ä–µ–π–º—ã\n"
    opt_text += "‚Ä¢ –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –µ–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ\n"
    opt_text += "‚Ä¢ –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã based on performance\n"
    
    await query.edit_message_text(
        opt_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="analytics_recommendations")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ", callback_data="analytics_back")]
        ])
    )

@log_performance
async def analytics_recommendations(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Intelligent Recommendations"""
    query = update.callback_query
    user_id = query.from_user.id
    
    portfolio = user_data[user_id].get('portfolio', {})
    recommendations = AnalyticsEngine.generate_strategy_recommendations(portfolio)
    
    rec_text = "üí° *–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏*\n\n"
    
    if recommendations:
        for i, rec in enumerate(recommendations, 1):
            rec_text += f"{i}. {rec}\n"
    else:
        rec_text += "‚úÖ –í–∞—à–∞ —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ö–æ—Ä–æ—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã!\n"
        rec_text += "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å —Ç–µ–∫—É—â–∏–π –ø–æ–¥—Ö–æ–¥.\n\n"
    
    rec_text += "\nüöÄ *–°–∫–æ—Ä–æ –ø–æ—è–≤–∏—Ç—Å—è:*\n"
    rec_text += "‚Ä¢ ü§ñ AI-–∞–Ω–∞–ª–∏–∑ –≤–∞—à–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π\n"
    rec_text += "‚Ä¢ üìä –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –±—ç–∫—Ç–µ—Å—Ç–∏–Ω–≥\n"
    rec_text += "‚Ä¢ üìà –ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏\n"
    rec_text += "‚Ä¢ üí° –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ç–æ—Ä–≥–æ–≤—ã–µ –∏–¥–µ–∏"
    
    await query.edit_message_text(
        rec_text,
        parse_mode='Markdown',
        reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("üìà –ê–Ω–∞–ª–∏–∑ —Ä–∏—Å–∫/–≤–æ–∑–Ω–∞–≥—Ä–∞–∂–¥–µ–Ω–∏–µ", callback_data="analytics_risk_reward")],
            [InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –∫ –∞–Ω–∞–ª–∏—Ç–∏–∫–µ", callback_data="analytics_back")]
        ])
    )

# Navigation handlers for portfolio and analytics
@log_performance
async def portfolio_back(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Back to portfolio menu"""
    return await portfolio_command(update, context)

@log_performance
async def analytics_back(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Back to analytics menu"""
    return await analytics_command(update, context)

# Update main menu handler to include new functionality
@log_performance
async def handle_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle main menu selection"""
    query = update.callback_query
    if not query:
        return MAIN_MENU
        
    await query.answer()
    choice = query.data
    
    # Update activity time
    user_id = query.from_user.id
    if user_id in user_data:
        user_data[user_id]['last_activity'] = time.time()
    
    if choice == "pro_calculation":
        return await start_pro_calculation(update, context)
    elif choice == "quick_calculation":
        return await start_quick_calculation(update, context)
    elif choice == "portfolio":
        return await portfolio_command(update, context)
    elif choice == "analytics":
        return await analytics_command(update, context)
    elif choice == "pro_info":
        await pro_info_command(update, context)
        return MAIN_MENU
    elif choice == "main_menu":
        return await start(update, context)
    elif choice == "portfolio_back":
        return await portfolio_command(update, context)
    elif choice == "analytics_back":
        return await analytics_command(update, context)
    
    return MAIN_MENU

# Update ConversationHandler states to include new functionality
def main():
    """Optimized main function to run bot"""
    token = os.getenv('TELEGRAM_BOT_TOKEN')
    if not token:
        logger.error("‚ùå PRO Bot token not found!")
        return

    logger.info("üöÄ Starting ULTRA-FAST PRO Risk Management Bot v3.0 with Enhanced Portfolio & Analytics...")
    
    # Create application
    application = Application.builder().token(token).build()

    # Configure ConversationHandler for main menu
    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler('start', start),
            CommandHandler('quick', quick_command),
            CommandHandler('portfolio', portfolio_command),
            CommandHandler('analytics', analytics_command),
            CommandHandler('info', pro_info_command),
            CommandHandler('presets', show_presets),
            CallbackQueryHandler(handle_main_menu, pattern='^(pro_calculation|quick_calculation|portfolio|analytics|pro_info|main_menu|portfolio_back|analytics_back)$')
        ],
        states={
            MAIN_MENU: [CallbackQueryHandler(handle_main_menu, pattern='^(pro_calculation|quick_calculation|portfolio|analytics|pro_info|main_menu|portfolio_back|analytics_back)$')],
            PORTFOLIO_MENU: [
                CallbackQueryHandler(portfolio_trades, pattern='^portfolio_trades$'),
                CallbackQueryHandler(portfolio_balance, pattern='^portfolio_balance$'),
                CallbackQueryHandler(portfolio_performance, pattern='^portfolio_performance$'),
                CallbackQueryHandler(portfolio_history, pattern='^portfolio_history$'),
                CallbackQueryHandler(portfolio_add_trade, pattern='^portfolio_add_trade$'),
                CallbackQueryHandler(portfolio_deposit, pattern='^portfolio_deposit$'),
                CallbackQueryHandler(handle_main_menu, pattern='^main_menu$'),
                CallbackQueryHandler(portfolio_back, pattern='^portfolio_back$')
            ],
            ANALYTICS_MENU: [
                CallbackQueryHandler(analytics_risk_reward, pattern='^analytics_risk_reward$'),
                CallbackQueryHandler(analytics_strategy_perf, pattern='^analytics_strategy_perf$'),
                CallbackQueryHandler(analytics_trade_stats, pattern='^analytics_trade_stats$'),
                CallbackQueryHandler(analytics_optimization, pattern='^analytics_optimization$'),
                CallbackQueryHandler(analytics_recommendations, pattern='^analytics_recommendations$'),
                CallbackQueryHandler(handle_main_menu, pattern='^main_menu$'),
                CallbackQueryHandler(analytics_back, pattern='^analytics_back$')
            ],
            # ... (rest of existing states)
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            CommandHandler('start', start),
            CommandHandler('presets', show_presets)
        ]
    )

    # Add handlers in correct order
    application.add_handler(conv_handler)
    
    # Add portfolio and analytics specific handlers
    application.add_handler(CallbackQueryHandler(portfolio_trades, pattern='^portfolio_trades$'))
    application.add_handler(CallbackQueryHandler(portfolio_balance, pattern='^portfolio_balance$'))
    application.add_handler(CallbackQueryHandler(portfolio_performance, pattern='^portfolio_performance$'))
    application.add_handler(CallbackQueryHandler(portfolio_history, pattern='^portfolio_history$'))
    application.add_handler(CallbackQueryHandler(portfolio_add_trade, pattern='^portfolio_add_trade$'))
    application.add_handler(CallbackQueryHandler(portfolio_deposit, pattern='^portfolio_deposit$'))
    
    application.add_handler(CallbackQueryHandler(analytics_risk_reward, pattern='^analytics_risk_reward$'))
    application.add_handler(CallbackQueryHandler(analytics_strategy_perf, pattern='^analytics_strategy_perf$'))
    application.add_handler(CallbackQueryHandler(analytics_trade_stats, pattern='^analytics_trade_stats$'))
    application.add_handler(CallbackQueryHandler(analytics_optimization, pattern='^analytics_optimization$'))
    application.add_handler(CallbackQueryHandler(analytics_recommendations, pattern='^analytics_recommendations$'))

    # ... (rest of existing handler additions)

    # Get webhook URL
    webhook_url = os.getenv('RENDER_EXTERNAL_URL', '')
    
    # Start webhook or polling
    port = int(os.environ.get('PORT', 10000))
    
    logger.info(f"üåê PRO Starting on port {port}")
    
    try:
        if webhook_url and "render.com" in webhook_url:
            logger.info(f"üîó PRO Webhook URL: {webhook_url}/webhook")
            application.run_webhook(
                listen="0.0.0.0",
                port=port,
                url_path="/webhook",
                webhook_url=webhook_url + "/webhook"
            )
        else:
            logger.info("üîÑ PRO Starting in polling mode...")
            application.run_polling()
    except Exception as e:
        logger.error(f"‚ùå Error starting PRO bot: {e}")

if __name__ == '__main__':
    main()
